\section*{Scheduling}
\textbf{OS typically schedule threads and not processes}

\subsection*{Basic concepts}
\begin{description}
  \item[Scheduling queue] OS maintains a ready and wait (i.e. waiting for I/O or for child termination or for interrupt to be serviced) queue.
  \item[Short-term scheduler] Selects P which should be brought from ready queue to memory and allocates CPU time.
  \item[Long-term scheduler] Selects P which should be brought from job pool (possibly on disk) to ready queue
  \item[Dispatcher] Component, which gives control of CPU to P. Jobs: switching context, switching to user mode, jumping to proper location in program.
  \item[Starvation] A P has little to no CPU-time
  \item[Aging] The waiting time of a P is taken into account.
\end{description}

\subsection*{Scheduling Criteria}
\begin{description}
  \item[CPU utilization] $100 * cpu\_busy\_time / total\_time$
  \item[Throughput] $number\_of\_finished\_Ps_/time\_unit$
  \item[Turnaround time] Amount of time to complete a particular P $waiting\_time+exec\_time+i\_o\_time$
  \item[Waiting time] Amount of time a P is waiting in ready queue
  \item[Response time] time it takes from when a request was submitted until first response is produced by P. (e.g. web server handling request)
\end{description}

\subsection*{Scheduling Algorithms}
\begin{description}
  \item[First Come, First Served (FCFS)] Can lead to convoy effect, i.e. short P's waiting for long P's (starvation), which causes long avg. waiting time.
  \item[Shortest-Job-First (SJF)] Length of CPU-burst estimated with previous CPU-bursts of P. Is optimal, bc minimizes average waiting time.
  \item[Shortest-remaining-time-first (SRFT)] SJF with preemption, i.e. when P arrives with shorter burst-time than current running one, then current P is stopped and new P can run.
  \item[Priority scheduling (Prio)] Each P has fixed priority number. Lower number = higher priority. Higher priority first.
  \item[Round Robin (RR)] FCFS with preemption. each P can run for max fixed time q (\textbf{quantum time}). if q large $\leadsto$ FCFS , q small $\leadsto$ Context switching overhead.
  \item[Multilevel Queue Scheduling (MLQ)] Ready queue partitioned into separate ready queues. With each queue a priority number is associated. Each queue has own scheduling algorithm (e.g. foreground tasks with RR and background tasks with FCFS). A P is permanently in a given queue. If MQL preemptive $\leadsto$ starvation.
  \item[Multilevel Feedback Queue (MLFQ)] Like MLQ, but Ps can move between various queues (e.g. Ps with short burst-time or long waiting-time go to higher-priority queues). This avoids starvation. MLFQ is the most general algorithm, since it can be configured in many ways.
\end{description}

\subsection*{Thread Scheduling}
\begin{description}
  \item[Process Contention Scope (PCS)] Competition for CPU time is  among Ts within the same P. The user-level T library schedules, OS not involved in scheduling.
  \item[System Contention Scope (SCS)] Ts from different Ps, as well as Ts within the same P, compete for CPU time. OS is scheduling Ts. OS using one-to-one mapping model schedule Ts only using SCS.
\end{description}
